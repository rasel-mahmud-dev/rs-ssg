import path from 'path';
import fs from 'fs-extra';
import { build } from 'esbuild';

// Enhanced plugin that handles component resolution
export const componentResolutionPlugin = {
    name: 'component-resolution',
    setup(build) {
        // Resolve relative imports from pages to components
        build.onResolve({ filter: /^\.\.\/components\// }, (args) => {
            // Convert relative path to absolute path
            const componentPath = path.resolve(args.resolveDir, args.path);

            // Check if file exists with .jsx extension
            if (fs.existsSync(componentPath)) {
                return { path: componentPath };
            }

            // Try with .jsx extension if not specified
            const jsxPath = componentPath.endsWith('.jsx') ? componentPath : componentPath + '.jsx';
            if (fs.existsSync(jsxPath)) {
                return { path: jsxPath };
            }

            // Try with .js extension
            const jsPath = componentPath.replace('.jsx', '.js');
            if (fs.existsSync(jsPath)) {
                return { path: jsPath };
            }

            return null;
        });

        // Handle other relative imports
        build.onResolve({ filter: /^\.\.?\// }, (args) => {
            const resolvedPath = path.resolve(args.resolveDir, args.path);

            // Try different extensions
            const extensions = ['.jsx', '.js', '.ts', '.tsx'];

            for (const ext of extensions) {
                const pathWithExt = resolvedPath.endsWith(ext) ? resolvedPath : resolvedPath + ext;
                if (fs.existsSync(pathWithExt)) {
                    return { path: pathWithExt };
                }
            }

            return null;
        });
    }
};


// Alternative approach: Copy components to a resolvable location
const copyComponentsPlugin = {
    name: 'copy-components',
    setup(build) {
        build.onStart(async () => {
            // Copy components to dist for easier resolution
            const srcComponents = path.resolve(process.cwd(), 'playground/src/components');
            const distComponents = path.resolve(process.cwd(), 'dist/components');

            if (fs.existsSync(srcComponents)) {
                await fs.copy(srcComponents, distComponents);
                console.log('ðŸ“ Copied components for build resolution');
            }
        });

        // Resolve component imports to the copied location
        build.onResolve({ filter: /^\.\.\/components\// }, (args) => {
            const componentName = args.path.replace('../components/', '');
            const resolvedPath = path.resolve(process.cwd(), 'dist/components', componentName);

            // Add .jsx extension if not present
            const finalPath = resolvedPath.endsWith('.jsx') ? resolvedPath : resolvedPath + '.jsx';
            return { path: finalPath };
        });
    }
};

// Alternative build configuration using copy approach
/*
let buildResult = await build({
    entryPoints: pages,
    bundle: true,
    outdir: 'dist/assets',
    format: 'esm',
    minify: false,
    splitting: true,
    jsx: 'automatic',
    metafile: true,
    entryNames: '[name]-[hash]',

    external: [],
    target: ['es2020', 'chrome80', 'firefox78', 'safari14'],

    define: {
        'process.env.NODE_ENV': '"production"'
    },

    plugins: [
        copyComponentsPlugin, // Alternative approach
        viteStyleNamingPlugin,
    ],

    banner: {
        js: '// Generated by esbuild with copied components'
    }
});
*/

// Path alias approach (most elegant)
const pathAliasPlugin = {
    name: 'path-alias',
    setup(build) {
        // Set up @ alias pointing to playground/src
        build.onResolve({ filter: /^@\// }, (args) => {
            const targetPath = path.resolve(process.cwd(), 'playground/src', args.path.slice(2));

            // Try with different extensions
            const extensions = ['', '.jsx', '.js', '.ts', '.tsx'];
            for (const ext of extensions) {
                const fullPath = targetPath + ext;
                if (fs.existsSync(fullPath)) {
                    return { path: fullPath };
                }
            }

            return null;
        });

        // Set up ~components alias
        build.onResolve({ filter: /^~components\// }, (args) => {
            const componentPath = args.path.replace('~components/', '');
            const targetPath = path.resolve(process.cwd(), 'playground/src/components', componentPath);

            const extensions = ['', '.jsx', '.js', '.ts', '.tsx'];
            for (const ext of extensions) {
                const fullPath = targetPath + ext;
                if (fs.existsSync(fullPath)) {
                    return { path: fullPath };
                }
            }

            return null;
        });
    }
};
