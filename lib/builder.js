import path from 'path'
import fs from "fs-extra";
import {build} from 'esbuild';
import RenderPage from "./renderPage.js";

import {generateManifest, getManifest} from "./utils/generateManifest.js";

import viteStyleNamingPlugin from "./viteStyleNamingPlugin.js";
import tailwindPlugin from "esbuild-plugin-tailwindcss";
import generateSitemap from "./utils/generateSitemap.js";
import generateRobotsTxt from "./utils/generateRobotsTxt.js";
import chalk from "chalk";


class Builder {

    constructor(config) {
        this.config = config
        this.renderPage = new RenderPage(config)
    }

    async build(routes) {
        const {buildDir, projectRoot, configSeo} = this.config

        console.log(chalk.cyan.bold("ðŸš€ Starting static site build...\n"));

        console.log(chalk.yellow("ðŸ§¹ Cleaning output directory..."));
        await fs.remove(path.join(projectRoot, buildDir));
        console.log(buildDir, "buildDir")


        console.log(chalk.green("âœ” Cleaned\n"));

        console.log(chalk.yellow("ðŸ“¦ Building SSR bundle..."));

        if (!routes || routes.length === 0) {
            console.log(chalk.red("âŒ No routes found! Please define routes in src/routes.jsx"));
            throw new Error("No routes found!");
        }

        const pages = routes?.map((route) => {
            return route.entry
        })

        console.log(chalk.green("âœ” SSR bundle built\n"));

        // Client bundle
        console.log(chalk.yellow("ðŸ’» Building client bundle..."));

        let buildResult = await build({
            entryPoints: pages,
            bundle: true,
            outdir: `${this.config.buildDir}/assets`,
            format: 'esm',
            minify: true,
            splitting: true,
            jsx: 'automatic',
            metafile: true,
            chunkNames: '[name]-[hash]',
            external: [],
            define: {
                'process.env.NODE_ENV': '"production"',
            },

            plugins: [
                viteStyleNamingPlugin,
                tailwindPlugin({})
            ],
            entryNames: '[name]-[hash]',
            banner: {
                js: '// Generated by esbuild with Vite-style naming'
            },

        });

        const clientJsxFile = path.resolve(this.config.projectRoot, 'src/client.jsx')

        await fs.remove(path.resolve(`${this.config.buildDir}/ssr-c`));
        let buildResult3 = await build({
            entryPoints: [clientJsxFile],
            bundle: true,
            outdir: `${this.config.buildDir}/ssr-c`,
            format: 'esm',
            minify: true,
            splitting: true,
            jsx: 'automatic',
            metafile: true,
            chunkNames: '[name]-[hash]',
            external: [],
            define: {
                'process.env.NODE_ENV': '"production"'
            },
            plugins: [
                viteStyleNamingPlugin,
                tailwindPlugin({})
            ],
            entryNames: '[name]-[hash]',
            plugins: [
                viteStyleNamingPlugin,
                tailwindPlugin({})
            ],
        });


        console.log(chalk.green("âœ” Client bundle built\n"));

        console.log(chalk.yellow("ðŸ“ Generating asset manifest..."));
        const client = await getManifest(buildResult3.metafile, buildResult3);
        const clientjs = Object.values(client)[0]?.file;
        const globalCss = client["client.css"]?.file;

        await generateManifest(buildResult.metafile, buildResult);
        console.log(chalk.green("âœ” Manifest generated\n"));

        console.log(chalk.yellow("ðŸ“„ Rendering static pages..."));
        await this.renderPage.generateStaticPages(routes, {
            scripts: clientjs ? [clientjs] : [],
            styles: globalCss ? [globalCss] : [],
        });
        console.log(chalk.green("âœ” Static pages rendered\n"));

        console.log(chalk.yellow("ðŸ“ Copying public assets..."));
        const publicDir = path.resolve(process.cwd(), "public");
        if (await fs.pathExists(publicDir)) {
            await fs.copy(publicDir, path.resolve(process.cwd(), buildDir));
            console.log(chalk.green("âœ” Public assets copied\n"));
        } else {
            console.log(chalk.gray("â„¹ No public directory found, skipping\n"));
        }

        // await fs.remove(path.resolve(projectRoot, `${buildDir}/.manifest.json`));

        // console.log(chalk.yellow("ðŸ—º Generating sitemap..."));
        // const xml = generateSitemap(routes.map((r) => r.path), configSeo.siteUrl);
        // fs.writeFileSync(`${buildDir}/sitemap.xml`, xml);
        // console.log(chalk.green("âœ” Sitemap generated\n"));
        //
        // console.log(chalk.yellow("ðŸ¤– Generating robots.txt..."));
        // const robotsTxt = generateRobotsTxt({
        //     baseUrl: configSeo.siteUrl,
        // });
        // fs.writeFileSync(`${buildDir}/robots.txt`, robotsTxt);
        // console.log(chalk.green("âœ” robots.txt generated\n"));

        console.log(chalk.cyan.bold("\nâœ… Static site built successfully!"));
        console.log(chalk.gray(`ðŸ“‚ Output directory: ${chalk.white(buildDir)}/\n`));
    }

}

export default Builder